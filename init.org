-*- eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t) -*-

* Tangling Hook
  There are two main approaches to writing your emacs configuration in
  org-mode:
  - org-babel-load-file. This approach is very simple to implement,
    but has to tangle each file when emacs starts.
  - org-babel-tangle. This approach stores the tangled file on disk,
    but you have to remember to re-tangle after each edit.


  We can use a file-local after-save-hook to do the tangling
  automatically. However, this file variable is not considered safe by
  default, so emacs will prompt you the first time you open this
  file.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq safe-local-variable-values '((eval add-hook 'after-save-hook
                                             (lambda nil (org-babel-tangle))
                                             nil t)))
  #+END_SRC
** Further Reading
   - https://www.reddit.com/r/emacs/comments/372nxd/
** TODO Async
   Tangling produces a noticeable pause every time I save. This should
   be pushed off the main thread.
   - https://www.reddit.com/r/emacs/comments/5ej8by/
   - https://emacs.stackexchange.com/q/22722
* [[https://github.com/raxod502/straight.el][straight.el]]
  I like straight.el philosophically - clones and lockfiles "feels"
  like the right way to solve this problem - and I don't mind having
  to give up package.el for those benefits. Extensive documentation is
  also greatly appreciated.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (let ((bootstrap-file (concat user-emacs-directory "straight/bootstrap.el"))
          (bootstrap-version 2))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))

    (setq use-package-always-ensure t)
    (straight-use-package 'use-package)
  #+END_SRC
* [[https://github.com/emacscollective/no-littering][no-littering]]
  This keeps files like projectile-known-projects-file where they
  belong.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package no-littering
      :demand t)
  #+END_SRC
* [[https://github.com/noctuid/general.el][general]]
  general provides a unified interface for binding keys. I use ~SPC~
  and ~DEL~ as my leaders, since my keyboard puts them under my left
  and right thumbs.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package general
      :demand t
      :config
      (general-create-definer private/with-leader
                              :prefix "SPC"
                              :non-normal-prefix "M-SPC"
                              :states '(normal visual insert emacs))
      (general-create-definer private/with-local-leader
                              :prefix "DEL"
                              :non-normal-prefix "M-DEL"
                              :states '(normal visual insert emacs)))
  #+END_SRC
* [[https://github.com/emacs-evil/evil][evil]]
  I never really became fluent in vim, but my brief experience made it
  impossible to go back to any other editing system. The two big
  innovations of vim were:
  - separate modes for binding commands and inserting text
  - composable operators and text objects


  I'm not married to anything specific in vim or evil besides those
  two principles, but nothing really comes close, and I'm not in the
  mood to roll my own version of evil right now.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil
      :demand t
      :diminish 'undo-tree-mode
      :init
      (setq evil-want-Y-yank-to-eol t)
      (setq evil-disable-insert-state-bindings t)
      :config
      (evil-mode t)
      :general
      (:states '(normal visual)
       ";" 'evil-ex
       "s" 'save-buffer
       "x" 'other-window
       "r" 'universal-argument)
      (:keymaps 'universal-argument-map
       "r" 'universal-argument-more)
      (private/with-leader
       "SPC" 'execute-extended-command
       ";" 'eval-expression
       "f" 'find-file
       "b" 'switch-buffer)
      (private/with-leader
       :infix "h"
       "h" 'help-for-help
       "f" 'describe-function
       "v" 'describe-variable
       "k" 'describe-key
       "m" 'describe-mode
       "w" 'where-is)
      (private/with-leader
       :infix "d"
       "h" 'split-window-vertically
       "v" 'split-window-horizontally
       "x" 'delete-window
       "k" 'kill-buffer-and-window))
  #+END_SRC
* [[https://github.com/abo-abo/swiper][ivy, counsel, swiper]]
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ivy
      :demand t
      :diminish 'ivy-mode
      :init
      (setq ivy-count-format "(%d/%d) ")
      :config
      (ivy-mode t)
      :general
      (:keymaps 'ivy-minibuffer-map
       "<escape>" 'abort-recursive-edit)
      ([remap switch-buffer] 'ivy-switch-buffer))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel
      :demand t
      :diminish 'counsel-mode
      :config
      (counsel-mode t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ivy-hydra
      :commands (hydra-ivy/body))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package swiper
      :general
      (private/with-leader
       "/" 'swiper))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package wgrep
      :commands (wgrep-change-to-wgrep-mode)
      :init
      (setq wgrep-auto-save-buffer t)
      :general
      (:keymaps 'wgrep-mode-map
       [remap save-buffer] 'wgrep-finish-edit))
  #+END_SRC
** TODO Structured Find/Replace
   This is a big topic, but I'm just going to stick it here because
   it's all going through ivy one way or another.
*** swiper
    swiper is my primary tool for structured find. It's incremental
    (ie it shows me where I'm going before I decide to go there) and
    ephemeral (ie if I dismiss the minibuffer it leaves no traces of
    its presence). One useful addition would be an easy way to resume
    the previous swiper search. ivy-resume, maybe?
*** isearch
    I have experimented with isearch (which is hooked into evil's ~/~
    by default). I find it most useful as a motion - ie when I already
    know exactly what I'm looking for with very high specificity - but
    avy works almost as well in those situations.

    I don't like using it for "searching". Jumping around with ~nN~ is
    cumbersome, and often after a few jumps you realize that you
    should have refined the search expression a bit more. With swiper,
    you can just scroll the minibuffer, and if you need to narrow it
    down, you can type in more text. I'm considering just binding
    swiper directly to ~/~.
*** occur/wgrep
    I find wgrep very useful for transitioning from search to replace.
    However, it takes multiple keybinds that I can never remember
    (first you have to occur from the minibuffer, then in the occur
    buffer you have to enable wgrep). I would like to abbreviate those
    bindings or make them less obscure.
*** rg
    There's probably some argument to be made for using rg (already
    projectile-integrated) in larger searches. We'll see where that
    fits into the picture. I just haven't used it enough yet. I
    believe the occur/wgrep system works just as well here as it does
    for swiper.
*** :s
    For smaller find/replaces, I still use vim's trusty ~:s~. The
    syntax of ~:s~ lets you write the find and replace halves of the
    expression simultaneously in a very nimble way. Automatically
    reusing the last pattern from ~/~ is also a nice feature, although
    a bit niche. I only feel the need to do that when I'm replacing a
    fairly complex pattern, which is usually a sign to reach for
    another tool.

    Once you start replacing a lot of stuff (more than a screenful) or
    really complicated stuff (anything involving eval-based
    expressions), ~:s~ becomes unpredictable and too cumbersome to use
    off hand. It works best when its effects are transparent and
    obvious.

    Speaking of transparency, evil's live preview for ~:s~ is
    extremely valuable. However, I've encountered some bugs with it
    (typically when replacing leading whitespace) where the
    preview markers don't go away after the command is done.

    It probably sounds like I like ~:s~ and I'm happy with its place
    in my workflow. For the most part, I am, but it's literally the
    only ex command I use regularly. If I can replace it with
    something else, that lets me completely rebind ~;:~ to other
    commands. [[https://github.com/benma/visual-regexp.el][visual-regexp]] or [[https://github.com/zk-phi/phi-search][phi-search]]? My requirements:
    - robust live preview
    - edit find and replace sides simultaneously, ideally with similar
      syntax to ~:s~
    - a quick keybind to jump from find to replace or vice versa
      (useful in longer expressions)
    - easy integration with swiper/rg and occur/wgrep, if you realize
      that you're biting off more than you can chew
*** iedit/multiple-cursors
    I've heard [[https://sam217pa.github.io/2016/09/11/nuclear-power-editing-via-ivy-and-ag/][good]] [[https://oremacs.com/2015/01/27/my-refactoring-workflow/][things]] about iedit, and I'm also interested in
    multiple-cursors:
    - [[https://github.com/victorhge/iedit][iedit]]
    - [[https://github.com/syl20bnr/evil-iedit-state][evil-iedit-state]]
    - [[https://github.com/hlissner/evil-multiedit][evil-multiedit]]
    - [[https://github.com/gabesoft/evil-mc][evil-mc]]
    - [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]
* [[http://orgmode.org/][org]]
  Note that straight.el will always install a fresh org-mode from
  [[https://github.com/emacsmirror/org][emacsmirror]] (which, unlike org's ELPA, can be cloned over TLS). This
  repository is immense. We're waiting for [[https://github.com/raxod502/straight.el/issues/2][shallow clone]] support.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package org
      :init
      (setq org-M-RET-may-split-line nil)
      (setq org-blank-before-new-entry '((heading . nil)
                                         (plain-list-item . nil)))
      (setq org-catch-invisible-edits 'smart)
      (setq org-ellipsis "â¤µ")
      (setq org-return-follows-link t)
      (setq org-src-fontify-natively t)
      (setq org-src-tab-acts-natively t)
      (setq org-src-window-setup 'current-window)
      (setq org-file-apps '(("pdf" . system)
                            (auto-mode . emacs)
                            (system . "xdg-open %s")
                            (t . system)))
      :general
      (:states '(insert emacs)
       :keymaps 'org-mode-map
       "RET" 'org-return-indent)
      (private/with-local-leader
       :keymaps 'org-mode-map
       "/" 'counsel-org-goto
       "r" 'org-reveal
       "o" '(lambda (arg)
              (interactive "P")
              (end-of-line)
              (org-meta-return arg)
              (evil-append nil))
       "O" '(lambda (arg)
              (interactive "P")
              (beginning-of-line)
              (org-meta-return arg)
              (evil-append nil))))
  #+END_SRC
** org Navigation
   I'm very fond of counsel-org-goto. It Just Works, which can't be
   said for some of the things I tried in the past.

   org has org-goto built-in. However, I despise org's "open another
   buffer and fumble around in here" approach to navigation. You can
   customize org-goto to use ivy (org-goto-interface and
   org-outline-complete-in-steps), but I found that it choked on
   headlines with slashes in them. Perhaps it was an ivy bug.

   Rather than investigate the slashes problem with org-goto, I
   tolerated counsel-imenu for a while. You need to futz around with
   some variables (imenu-auto-rescan, imenu-auto-rescan-timeout) to
   make it rescan every time you use it. The real problem is that it
   only displays leaf-level headings, so you can't jump directly to
   intermediate headings.

   I've also heard of some other options like [[https://github.com/jrblevin/deft][deft]], [[https://github.com/facetframer/orgnav][orgnav]], and
   [[https://github.com/alphapapa/helm-org-rifle][helm-org-rifle]], but for now, counsel-org-goto is so close to my
   ideal implementation that I'm no longer shopping around. [[https://www.reddit.com/r/emacs/comments/4a4a8n/better_system_than_defthelmorgmode_to_manage_many/][See also]].
** TODO [[https://github.com/abo-abo/ace-link][ace-link]]
   A more powerful alternative to org-open-at-point. This should open
   the link at point (if any), and otherwise select one avy-style.
** TODO [[https://github.com/abo-abo/worf][worf]] Tree Mutation
   It's fine to use counsel-org-goto for large jumps, but for shorter
   movements, it's much faster to go up or down headings. worf has an
   especially elegant way of combining navigation and mutation of org
   trees. Unfortunately it doesn't play nice with evil.

   One important caveat of any up/down heading navigation is that it
   tends to pollute the jumplist. Ideally, you want to "enter" heading
   navigation mode, jump around headings freely, and add to the
   jumplist when you "exit" heading navigation mode. I used to have a
   hydra for this, and might rebuild it.
** TODO org-agenda
   I probably want to set org-agenda-files to something under
   no-littering, and then add basically every org file I open to it.
** TODO org Indentation
   Right now, plain text in org-mode is indented to match the level of
   the headline. This is enforced by two configuration tweaks:
   - I bind ~RET~ to org-return-indent, since org-mode disables
     electric-indent-mode. If I removed this binding, pressing ~RET~
     in org-mode would leave unindented text. Pressing ~TAB~ in that
     unindented text would indent it, because...
   - I leave org-cycle-emulate-tab on its default value of t, which
     causes ~TAB~ to behave normally (ie indenting) in plain text.
     Setting this to nil prevents that behavior, causing ~TAB~ to just
     cycle the subtree that contains the text (which is actually
     useful behavior in its own right, because it's a quick way to
     jump back up to the containing heading).


   However, there's a bigger question of whether indentation in
   org-mode is actually useful. Moving text up and down headings is a
   lot more annoying when the text is indented by different levels. I
   also believe it interferes with beancount (which can be embedded in
   org-mode, but doesn't support indented directives).

   On the other hand, I tried unindenting this file and found that it
   drastically hurt readability (my eyes were instinctively scanning
   the left edge of the screen to identify the headline boundaries). I
   didn't even realize that would be a problem until I saw it. So,
   while I would like to get rid of indentation, we need to maintain
   readability to do so. A few tweaks might help:
   - currently I do not insert any blanks before new headings
     (org-blank-before-new-entry), but if there's no indentation, I
     might want to turn that back on.
   - I'm still using emacs's default theme, which only distinguishes
     headings using color. Back when I took notes in markdown, this
     was fine because I surrounded every heading with an empty line
     above and below, but org-mode is denser due to the previous
     point. I could increase the font size of headings to make them
     stand out more. This is particularly important if the heading is
     next to another colored element, like a keyword.
** TODO org Completion
   I hate typing out org keywords (~#+BEGIN_SRC~, etc) by hand. You
   can type them in lowercase (which I should really start doing), but
   even better would be autocomplete for them. Autocompletion is
   unfortunately a TODO in its own right, but perhaps we can hack up
   an interim solution with ivy.
* Built-ins
  This is for built-in emacs miscellany that I want to reconfigure or
  turn off. There's quite a bit of stuff in here.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq auto-save-default nil)
    (setq auto-save-list-file-prefix nil)
    (setq create-lockfiles nil)
    (setq make-backup-files nil)

    (setq initial-major-mode 'org-mode)
    (setq initial-scratch-message nil)

    (setq-default truncate-lines t)
    (setq visual-line-fringe-indicators '(left-curly-arrow nil))

    (setq echo-keystrokes 0.1)

    (setq sentence-end-double-space nil)

    (setq menu-bar-mode nil)
    (setq tool-bar-mode nil)

    (setq frame-title-format "%b")

    (setq save-interprogram-paste-before-kill t)

    (setq global-hl-line-sticky-flag t)
    (global-hl-line-mode t)
    (show-paren-mode t)

    (setq-default indent-tabs-mode nil)

    (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)

    (setq uniquify-buffer-name-style 'forward)

    (setq require-final-newline t)

    (setq load-prefer-newer t)
  #+END_SRC
** TODO visual-line-mode
   visual-line-mode is a built-in mode that truncates lines at word
   boundaries. adaptive-wrap-mode (GNU ELPA) extends it to also
   preserve leading indentation. I have not had positive experiences
   with this part of emacs:
   - [[https://github.com/abo-abo/swiper/issues/227][swiper, org, and visual-line-mode]] cause some very strange issues
     when used together
   - apparently it doesn't like [[https://github.com/brentonk/adaptive-wrap-vp][variable-width fonts]] ([[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=15155][see also]])
   - apparently it doesn't like [[https://gist.github.com/tsavola/6222431][hard tabs]] either


   I consider hard-filling paragraphs to be an ugly implementation
   detail that my editor is supposed to render irrelevant. It doesn't
   help that auto-fill-mode is not applicable to everything I write.
   emacs is really not doing the job here.
** TODO Indentation
   You can see that I set indent-tabs-mode to nil by default. I really
   do not like setting indentation behavior in my config. I used to
   use [[https://github.com/tpope/vim-sleuth][vim-sleuth]] and it was magical. You never had to tell it
   anything; it just knew what the right settings were. That's what
   indentation configuration is supposed to feel like. I've heard that
   [[https://github.com/jscheid/dtrt-indent][dtrt-indent]] can provide similar functionality for emacs.

   I haven't had to edit any "real" code in emacs yet, so remapping
   org-return-indent was sufficient for me, but I'd also like to look
   into electric-indent-mode (built-in) or [[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent-mode]] to
   do this automatically.
* [[https://github.com/lewang/ws-butler][ws-butler]]
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ws-butler
      :demand t
      :diminish 'ws-butler-mode
      :init
      (setq ws-butler-keep-whitespace-before-point nil)
      :config
      (ws-butler-global-mode t))
  #+END_SRC
* [[https://github.com/bbatsov/projectile][projectile]] with [[https://github.com/ericdanan/counsel-projectile][ivy]] integration
  I mainly use projectile for fuzzy searching an entire project's
  files and buffers. It's quite refreshing to never think about what
  files are "open" and which ones aren't. The concept of a "root"
  directory is also important for things like rg searching.

  A recent tweak to projectile's modeline causes immense UI lag, which
  is what the custom modeline snippet is for. See more [[https://github.com/bbatsov/projectile/issues/1183#issuecomment-335569547][here]].

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package projectile
      :demand t
      :init
      (setq projectile-mode-line
            '(:eval (format " Projectile[%s]" (projectile-project-name))))
      :config
      (projectile-mode t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel-projectile
      :init
      (setq counsel-projectile-drop-to-switch-project-binding "C-SPC")
      :config
      (counsel-projectile-on)
      :general
      (private/with-leader
       :infix "p"
       "f" 'counsel-projectile
       "/" 'counsel-projectile-rg
       "p" 'counsel-projectile-switch-project))
  #+END_SRC
* [[https://github.com/abo-abo/avy][avy]]
  One of the unpleasant truths of vim is that, although there are
  structured motions for everything, you're probably going to start
  out by holding down hjkl a lot. It takes a long time for all those
  other motions to seep into your muscle memory. avy provides a
  command that quickly gets anywhere on the screen, regardless of how
  the buffer is formatted. It reflects a "lazy vim" approach of using
  cheap, general commands that you'll never have to think about.

  evil actually [[https://github.com/emacs-evil/evil/blob/master/evil-integration.el][defines]] motion wrappers for avy. However, its wrappers
  are inclusive, and I vastly prefer exclusivity for "jump to first
  instance" motions, so I redefine them.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package avy
      :init
      (setq avy-all-windows nil)
      :config
      (evil-define-avy-motion avy-goto-char-2-above exclusive)
      (evil-define-avy-motion avy-goto-char-2-below exclusive)
      :general
      (:states '(motion)
       "f" 'avy-goto-char-2-below
       "F" 'avy-goto-char-2-above))
  #+END_SRC
** TODO read-char ~ESC~
   avy uses read-char to receive input. It seems I can only cancel it
   with ~C-g~. Is there really no way to use ~ESC~ or ~<escape>~
   instead?
** TODO Repeat
   One nice feature of [[https://github.com/justinmk/vim-sneak][vim-sneak]] is that, after your initial search,
   you can mash the key to go to the next or previous instance. Such
   behavior could also be useful here. It would be something like this:
   - when you first press ~fF~, you get prompted for the search
     argument (same as existing avy)
   - the matching candidates get highlighted under a trie (same as
     existing avy)
   - typing the keys for that candidate jumps you to it (same as
     existing avy)
   - after the first jump, mashing ~fF~ takes you to the next/previous
     instance of the same search argument
   - the jumplist only gets updated once for the entire search chain


   Look into [[https://github.com/hlissner/evil-snipe][evil-snipe]], perhaps?
** TODO ~tT~
   If we have bindings for ~fF~, should we add ~tT~ as well? What
   would they do? We could also use ~ft~ instead of ~fF~, which is one
   less press of the shift key.

   While we're at it, maybe having separate keys for forward and
   backward is a waste of brain cycles, and we should just use
   avy-goto-char-2.
* [[https://github.com/abo-abo/ace-window][ace-window]]
  Forget obtuse up/down/left/right-based window switching. It takes up
  a ton of binding space and it's not even the fastest way to move
  around. ace-window lets you jump to any window with one key. You can
  hook into it to do a lot of other window-management-related things,
  but I use it for its barebones functionality, and it works like a
  charm.

  I use a nasty hack to increase the size of the ace-window marker
  character. You can probably do this with custom-set-faces, whose use
  I try to avoid.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ace-window
      :init
      (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
      (setq aw-scope 'frame)
      (setq aw-dispatch-alist '((?z aw-flip-window)))
      :config
      (face-spec-set 'aw-leading-char-face
        '((((class color)) (:foreground "red" :height 3.0))
          (((background dark)) (:foreground "gray100" :height 3.0))
          (((background light)) (:foreground "gray0" :height 3.0))
          (t (:foreground "gray100" :underline nil :height 3.0))))
      :general
      ([remap other-window] 'ace-window))
  #+END_SRC
** TODO Dispatch
   You can do a lot of interesting window related stuff with
   aw-dispatch-alist, which could probably replace my entire ~SPC d~
   leader tree. Definitely worth investigating. Integrating desktop
   management keybinds (eg eyebrowse, see below) would also be
   appropriate.
* [[https://github.com/wasamasa/shackle][shackle]]
  shackle keeps temporary windows out of the way. emacs has a nasty
  tendency to spawn them in the first free window it can find, and if
  you have your windows laid out just right, that's usually not what
  you wanted. I'm used to vim's "help pops up at the bottom" approach,
  and shackle lets me have that.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package shackle
      :demand t
      :diminish 'shackle-mode
      :init
      (setq shackle-rules '((help-mode :select t
                                       :popup t
                                       :align 'below
                                       :size 0.5)))
      :config
      (shackle-mode t))
  #+END_SRC
* TODO Other Improvements
  - https://github.com/emacs-tw/awesome-emacs
  - https://github.com/hlissner/.emacs.d/
  - https://github.com/noctuid/evil-guide
** TODO epub
   See [[https://github.com/wasamasa/nov.el][nov.el]].
** TODO Modeline and Frame Title
   I'm pretty happy with the built-in emacs modeline in terms of
   information, but it doesn't look flattering. Could use some
   customization. Matching improvements for frame title would also be
   appropriate.
   - https://www.reddit.com/r/emacs/comments/6ftm3x/
   - [[https://github.com/dbordak/telephone-line][telephone-line]]
   - [[https://github.com/milkypostman/powerline][powerline]]/[[https://github.com/TheBB/spaceline][spaceline]]
   - [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]]
** TODO Surround
   One of the few vim plugins I really got to know was [[https://github.com/tpope/vim-surround][surround]].
   Moving to emacs and having not picked up a similar plugin makes me
   wonder how anyone lives without that kind of functionality.
   - [[https://github.com/emacs-evil/evil-surround][evil-surround]]
   - [[https://github.com/cute-jumper/embrace.el][embrace]]
** TODO Pairs
   Automatic pair insertion saves a lot of time and generally reduces
   the cognitive load of keeping parentheses matched. As emacs is a
   lisp-heavy environment, a number of specialized packages exist
   specifically for lisp's uniquely paren-intensive requirements. An
   interesting overview was written [[https://github.com/shaunlebron/history-of-lisp-editing][here]]. Much ink has been shed on
   this topic, such as [[https://www.reddit.com/r/emacs/comments/4nvhu4/][here]].
   - paredit
   - [[https://github.com/DogLooksGood/parinfer-mode][parinfer]]
   - [[https://github.com/Fuco1/smartparens][smartparens]]
   - [[https://github.com/promethial/paxedit][paxedit]]
   - [[https://github.com/noctuid/lispyville][lispyville]]
   - [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]]
   - xah also has some interesting thoughts [[https://www.reddit.com/r/emacs/comments/3sfmkz/could_this_be_a_pareditsmartparens_killer/cwxocld/][here]]


   While we're on the subject of lisp, it would be nice to fix
   indentation of keyword blocks, as described [[https://github.com/kaushalmodi/.emacs.d/blob/6e815386ed6c84c5b417239b297d989e9a9c69ca/setup-files/setup-elisp.el#L133][here]]. One example of
   this in my config is in the ~:general~ sections of my use-package
   forms.

   Outside of lisp, it's still useful to have automatic pairs, but you
   don't really need anything else. Besides smartparens, there's also
   the built-in electric-pair-mode.
** TODO Comments
   emacs has two built-in commenting functions, comment-dwim and
   comment-line. There are some packages as well:
   - [[https://github.com/linktohack/evil-commentary][evil-commentary]]
   - [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]]
   - [[https://github.com/remyferre/comment-dwim-2][comment-dwim-2]]
** TODO Autocompletion
   Autocompletion is a huge time saver and can eliminate a lot of
   "whoops I forgot that argument's type" brain cycles. Unfortunately,
   the situation in emacs is [[https://www.reddit.com/r/emacs/comments/49ee8f/][not great]]. There are two main
   implentations, [[https://github.com/company-mode/company-mode][company]] and [[https://github.com/auto-complete/auto-complete][auto-complete]].
** TODO which-key
   Things like help-for-help and [[https://github.com/abo-abo/hydra/blob/master/hydra-ox.el][hydra-ox]] are basically key trees with
   built-in prompts. I find the persistence of hydras to be their main
   selling point. If all you want is the prompt, [[https://github.com/justbur/emacs-which-key][which-key]] is probably
   a better approach.
** TODO beancount
   beancount's repository contains its own [[https://bitbucket.org/blais/beancount/src/default/editors/emacs/beancount.el?at=default&fileviewer=file-view-default][emacs major mode]]. The repo
   is on bitbucket, but straight.el doesn't have hg support (should be
   reasonable to implement, if it comes to that). It appears that the
   mode hasn't been edited in a long time, so the [[https://github.com/beancount/beancount/blob/master/editors/emacs/beancount.el][github mirror]] should
   also work. I'll need straight.el to clone the repository and build
   the one elisp file.
** TODO git
   Obviously the elephant in this room is [[https://github.com/magit/magit][magit]], with support from
   other packages like [[https://github.com/vermiculus/magithub][magithub]] and [[https://github.com/emacs-evil/evil-magit][evil-magit]]. Some other important
   considerations:
   - [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]], [[https://github.com/syohex/emacs-git-gutter/][git-gutter]], or [[https://github.com/dgutov/diff-hl][diff-hl]]
   - [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]]
** TODO Desktops
   My goal is to have window arrangements segregated by project, like
   [[https://github.com/bbatsov/persp-projectile][persp-projectile]]. However, you need to have desktop management
   first to implement that, so I'm looking at [[https://www.reddit.com/r/emacs/comments/6sffrd/am_i_misunderstanding_eyebrowse/dlcfhwk/][rolling my own]] using
   [[https://github.com/wasamasa/eyebrowse][eyebrowse]]. It's also worth exploring [[https://github.com/ilohmar/wconf][wconf]], or the built-in
   winner-mode. Also: [[https://github.com/cyrus-and/zoom][zoom]].
** TODO Scroll
   I'm pretty comfortable with emacs's default scrolling behavior, but
   here are some packages to investigate:
   - [[https://github.com/aspiers/smooth-scrolling][smooth-scrolling]]
   - [[https://github.com/zk-phi/sublimity][sublimity]]
   - [[https://github.com/Malabarba/beacon][beacon]]
** TODO Dired
   I use ranger as my file manager these days. Theoretically, there's
   no reason I couldn't do that in emacs instead. However, vanilla
   dired is not fun. It's a pain to teach dired to open things in
   their native programs rather than in emacs. So there's a lot of
   work that needs to be added here:
   - wdired (built-in, similar to ranger's bulkrename)
   - [[https://github.com/fourier/ztree][ztree]]
   - [[https://github.com/ralesi/ranger.el][ranger.el]]
   - [[https://github.com/Fuco1/dired-hacks][dired-hacks]]
** TODO File Tree
   In practice, I vastly prefer navigating projects with recursive
   fuzzy search, as already provided by counsel-projectile. But
   there's something to be said for an interactive file tree when
   exploring a project whose structure you don't yet know. emacs has a
   number of options here:
   - [[https://github.com/jaypei/emacs-neotree][neotree]]
   - [[https://github.com/m2ym/direx-el][direx]]
   - [[https://github.com/Alexander-Miller/treemacs][treemacs]]
   - [[https://github.com/sabof/project-explorer][project-explorer]] (appears unmaintained)
** TODO mpd
   I grudgingly use ncmpcpp as my mpd client right now, but its
   interface is not customizable enough for my tastes. I would like a
   tree by genre/album/track/artist in that order (cmus has a tree,
   but it's artist/album only with no other options). What better
   place to implement a highly customizable text-based UI than emacs?
   - mpc (built-in)
   - [[https://www.gnu.org/software/emms/][EMMS]]
   - [[https://github.com/pft/mingus][mingus]]
   - [[https://github.com/nlamirault/dionysos][dionysos]]
** TODO Miscellaneous Packages
   - [[https://github.com/Malabarba/rich-minority][rich-minority]] (I currently use the diminish integration in
     use-package)
   - [[https://github.com/flycheck/flycheck][flycheck]]
   - [[https://github.com/bbatsov/crux][crux]]
   - [[https://github.com/bbatsov/super-save][super-save]]
   - [[https://github.com/joaotavora/yasnippet][yasnippet]]
   - [[https://github.com/dacap/keyfreq][keyfreq]]
   - [[https://github.com/nflath/hungry-delete][hungry-delete]] and/or [[https://github.com/hrehfeld/emacs-smart-hungry-delete][smart-hungry-delete]]
   - [[https://github.com/alezost/mwim.el][mwim]]
   - global-auto-revert-mode (built-in)
   - [[https://github.com/bbatsov/zenburn-emacs][zenburn]] (I should actually implement [[https://github.com/tummychow/pallor][pallor]] in emacs)
   - [[https://www.reddit.com/r/emacs/comments/4d8gvt/][auto close minibuffer]]
